"""
KamiCode â€” Auth Service

Business logic for user registration, authentication, and wallet linking.
"""

import uuid
from typing import Optional

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.security import create_access_token, hash_password, verify_password
from app.models.user import User
from app.schemas.auth import UserLogin, UserRegister


class AuthService:
    """Handles all authentication-related business logic."""

    @staticmethod
    async def register_user(db: AsyncSession, data: UserRegister) -> User:
        """
        Register a new user.

        Args:
            db: Database session.
            data: Registration data (username, email, password).

        Returns:
            The created User instance.

        Raises:
            ValueError: If username or email already exists.
        """
        # Check for existing username
        existing = await db.execute(
            select(User).where(User.username == data.username)
        )
        if existing.scalar_one_or_none():
            raise ValueError("Username already taken")

        # Check for existing email
        existing = await db.execute(
            select(User).where(User.email == data.email)
        )
        if existing.scalar_one_or_none():
            raise ValueError("Email already registered")

        # Create user (id auto-generated by model default)
        user = User(
            username=data.username,
            email=data.email,
            password_hash=hash_password(data.password),
            classical_rating=1200,
            blitz_rating=1200,
            league_tier="bronze",
        )
        db.add(user)
        await db.flush()
        return user

    @staticmethod
    async def authenticate_user(
        db: AsyncSession, data: UserLogin
    ) -> Optional[User]:
        """
        Authenticate a user by email and password.

        Args:
            db: Database session.
            data: Login credentials (email, password).

        Returns:
            The User instance if credentials are valid, None otherwise.
        """
        result = await db.execute(
            select(User).where(User.email == data.email.lower())
        )
        user = result.scalar_one_or_none()

        if user is None:
            return None

        if not verify_password(data.password, user.password_hash):
            return None

        return user

    @staticmethod
    def create_user_token(user: User) -> str:
        """Create a JWT access token for the given user."""
        return create_access_token(data={"sub": str(user.id)})

    @staticmethod
    async def get_user_by_id(db: AsyncSession, user_id: uuid.UUID) -> Optional[User]:
        """Fetch a single user by their UUID."""
        result = await db.execute(select(User).where(User.id == user_id))
        return result.scalar_one_or_none()

    @staticmethod
    async def link_wallet(
        db: AsyncSession, user: User, wallet_address: str
    ) -> User:
        """
        Link a crypto wallet to the user's account.

        Args:
            db: Database session.
            user: The authenticated user.
            wallet_address: The Ethereum wallet address to link.

        Returns:
            Updated User instance.

        Raises:
            ValueError: If the wallet is already linked to another account.
        """
        # Check if wallet is already linked to another user
        existing = await db.execute(
            select(User).where(
                User.wallet_address == wallet_address,
                User.id != user.id,
            )
        )
        if existing.scalar_one_or_none():
            raise ValueError("Wallet already linked to another account")

        user.wallet_address = wallet_address
        await db.flush()
        return user
